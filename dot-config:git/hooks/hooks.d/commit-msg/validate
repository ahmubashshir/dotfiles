#!/usr/bin/ruby
# Encoding: utf-8

editor = ENV['EDITOR'] != 'none' ? ENV['EDITOR'] : 'vim'
message_file = ARGV[0]
try = 0
return if message_file.nil?

def check_format_rules(line_number, line)
	real_line_number = line_number + 1
  	return "  error:#{real_line_number}: First line should be less than 50 characters in length." if line_number == 0 && line.length > 50
  	return "  error:#{real_line_number}: Second line should be empty." if line_number == 1 && line.length > 0
  	(return "  error:#{real_line_number}: No line should be over 72 characters long." if line.length > 72) unless line[0,1]  == '#'
  	false
end
print "\e[s"
while try+=1
	len = 0
	lines = 0
	commit_msg = []
	errors = []

	File.open(message_file, 'r').each_with_index do |line, line_number|
		commit_msg.push line
		e = check_format_rules line_number, line.strip
		errors.push e if e
		lines += 1 unless line[0,1]  == '#' 
	end
	if lines < 3 then
		errors.push "  error:#{lines}: No summery written."
	end

	unless errors.empty?
		if try > 1 then
			(0 .. len + 3).each do |idx|
				print "\e[1;F\e[0;K"
			end
		end
		print "[commit-msg] Invalid format\n\n"
		errors.each do |error|
			puts "  #{error}"
		end
		puts "\nInvalid git commit message format."
		print 'Fix this commit? [Y/n]  '
		choice = ''
		until %w[y n].include? choice.downcase
			print "\e[1;D"
			chc = $stdin.gets
			chc = chc == nil ? 'n' : chc.chomp
			choice = chc.length == 0 ? 'y' : chc
			print "\e[1;A"
		end
		len = errors.length
		exit 1 if choice.downcase == 'n'
			next if system("#{editor} '#{message_file}'")
		end
	break
end
