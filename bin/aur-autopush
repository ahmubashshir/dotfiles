#!/bin/bash
trap 'exit' INT
function lock
{
	local FD LOCKFILE
	FD=$(shuf -i 1-1000 -n 1)
	LOCKFILE="${1:-$PWD}/lock.lck"
	trap "no_more_locking $LOCKFILE" EXIT TERM

	eval "$(printf 'exec %d>%q' "$FD" "$LOCKFILE")"
	eval "$(printf '_lock() { flock -$1 %d; }' "$FD")"
	no_more_locking()
	{
		_lock u
		_lock xn && rm -f "$1"
		unset _lock
	}
	_lock xn || {
		echo "Failed to lock ${1:-$PWD}"
		return 1
	}
	ret=$?
	return $ret
}

# packaging related functions
function pypi:pkgver
{
	curl -s "https://pypi.org/pypi/$1/json" | jq -r '.info.version'
}

function github:pkgver
{
	curl -sH "Accept: application/vnd.github.v3+json" "https://${2:-api.github.com}/repos/$1/tags" \
		| jq -r 'if (.[]|length)>0 then .[0].name, halt else null end|.|=sub("v(?<ver>.*)";"\(.ver)")'
}

function gitlab:pkgver
{
	curl -s "https://${2:-gitlab.com}/api/v4/projects/${1//\//%2F}/repository/tags" \
		| jq -r 'if (.[]|length)>0 then .[0].name, halt else null end|.|=sub("v(?<ver>.*)";"\(.ver)")'
}

function snap:query
{
	test -z "$1" && return 1
	if ! grep -qE 'stable|candidate|beta|edge' <<< "$2"; then
		return 1
	fi
	curl --disable -s -H "Snap-Device-Series: 16" \
		"http://api.snapcraft.io/v2/snaps/info/$1" \
		| jq -r '."channel-map"[]
				 |select(.channel
					|[
						.name == "'"$2"'",
						.architecture != "i386",
						.track == "latest"
					 ]
					| all
				 )' 2> /dev/null
}

function snap:pkgver
{
	snap:query "$1" "$2" \
		| jq -r '.version
				 | tostring' 2> /dev/null \
		| sort --version-sort \
		| tail -n1
}

function snap:util
{
	local arch rev
	test -z "$3" && return 1
	snap:query "$1" "$2" \
		| jq -r 'select(.version == "'"$3"'")
				 |[
					.channel.architecture,
					(.revision | tostring)
				  ]
				 |join(" ")' 2> /dev/null \
		| sort --version-sort \
		| while read -r arch rev; do
			sed -Ei.bak \
				-e "/^_rev_$arch=[[:digit:]]+[[:blank:]]+#[[:blank:]]+snap:revision/d" \
				-e "/^_snap=/a\_rev_$arch=$rev # snap:revision" PKGBUILD
		done
}

function py:deps
{
	local -a overrides
	overrides=(
		-e 's/py(gobject|opengl)/\1/'
		-e 's/(jinja)2/\1/'
	)
	sed -E "${overrides[@]}"
}

function pip:deps
{
	sed -En "s/^([[:alnum:]_-]+)==([[:digit:].]+)\.\*,>=([[:digit:].]+)(|; sys_platform == \"linux\")$/python-\1<\2\npython-\1>=\3/p;s/^([[:alnum:]_-]+)$/python-\1/p" "$1" \
		| awk -F '<|\\.' '$0 ~ /<.*[[:digit:]]$/{print $1"<"$NF+1".0.0"};$0 !~ /<.*[[:digit:]]$/' \
		| py:deps
}

function pyproject:deps
{
	dephell deps convert \
		--from "${1:-pyproject.toml}" \
		--to-format=pip \
		--to-path=stdout 2> /dev/null | pip:deps -
}

function setuptools:deps
{
	dephell deps convert \
		--from setup.py \
		--to-format=pip \
		--to-path=stdout 2> /dev/null | pip:deps -
}

function pypi:deps
{
	curl -s "https://pypi.org/pypi/$1/json" \
		| jq -r '.info.requires_dist[]?' \
		| sed -En \
			's/^([[:alnum:]]+)\s*\(>=([[:digit:].]+),<([[:digit:].]+)\)(|; sys_platform == \"linux\")$/python-\1<\3\npython-\1>=\2/p' \
		| py:deps
}
export GIT_DISABLED_HOOKS=commit-msg.validate:prepare-commit-msg.restore:commit-msg.validate
shopt -s extglob

# script start
if (($# == 0)); then
	set -- ./*/
elif [[ $1 == --stdin ]]; then
	shift
	while read -r line; do
		set -- "$@" "$line"
	done
fi
locked=''
for pkgpath in "$@"; do
	repo="$(git -C "$pkgpath" rev-parse --show-toplevel 2> /dev/null)"
	if readlink "$repo/.git/hooks/prepare-commit-msg" 2> /dev/null \
		| grep -q '/aurpublish/' \
		|| test -f "$repo/.aurpublish"; then
		aurpublish=1
		if [ "$locked" != "$repo" ]; then
			if [ -f "$locked/lock.lck" ]; then
				rm -f "$locked/lock.lck"
			fi
			lock "$repo" || continue
			locked="$repo"
		fi
	fi
	if [[ -f "$pkgpath/PKGBUILD" && ! -e "$pkgpath/WIP" ]]; then
		if ((aurpublish)); then
			cd "$repo" || exit
			find . \
				-mindepth 1 -maxdepth 1 \
				-type d -not -name '.git' \
				-not -name "$(basename "$pkgpath")" -print0 \
				| git stash push --pathspec-from-file=- --pathspec-file-nul > /dev/null 2>&1
			cd "$OLDPWD" || exit
		fi
		# shellcheck disable=SC2031,SC2030
		(
			typeset -a exclude source
			pkgver=0
			pkgrel=0
			cd "$pkgpath" > /dev/null 2>&1 || exit
			lock || exit
			source ./PKGBUILD
			if git stash push -- . 2> /dev/null | grep -q '^Saved'; then
				stashed=1
			fi
			echo "Pulling from upstream: ${pkgbase:-$pkgname}"
			git pull
			if ((aurpublish)) && [[ ! -f .noaur ]]; then
				echo "Pulling from aur: ${pkgbase:-$pkgname}"
				aurpublish -p "$PWD"
			fi
			if ((stashed)); then
				git stash pop > /dev/null 2>&1
			fi
			source ./PKGBUILD
			srcdir=src
			from=$(awk '/^# from: /{print $3}' PKGBUILD)
			if test -n "$from"; then
				where=$(awk '/^# from: /{print $4}' PKGBUILD)
				what=$(awk '/^# what: /{print $3}' PKGBUILD)
				xgrep=$(awk '/^# match![[:space:]]+/{sub(/^# match![[:space:]]+/, "");print}' PKGBUILD)
				egrep=$(awk '/^# match:[[:space:]]+/{sub(/^# match:[[:space:]]+/, "");print}' PKGBUILD)
				case $from in
					pypi) tool=$from ;;
					*) tool=$(awk '/^# deps: / {print $3}' PKGBUILD) ;;
				esac

				case $from in
					bzr | git | hg | svn)
						makepkg -o -d --skipchecksums
						PKGVER=$(pkgver)
						;;
					*)
						if [ "$(type -t "$from:pkgver")" = "function" ]; then
							PKGVER=$("$from:pkgver" "${what:-${_name:-${pkgbase:-$pkgname}}}" "$where" | sed 's/-/_/g')
						else
							PKGVER=0
						fi
						;;
				esac
				if
					[[ 
						$(vercmp ${PKGVER//_/-} $pkgver) = 1 &&
						(-z "$xgrep" || ! ${PKGVER//_/-} =~ $xgrep) &&
						(-z "$egrep" || ${PKGVER//_/-} =~ $egrep) ]]
				then

					sed -Ei "s/^(pkgver=)(\"|'|)$pkgver(\"|'|)$/\1\2$PKGVER\3/g;s/^(pkgrel)=.*/\1=1/g" PKGBUILD
					msg="[${what:-${_name:-${pkgbase:-$pkgname}}}] Updated to $PKGVER-1"
				fi
				if type -t "${tool}:util" 2> /dev/null | grep -wq function; then
					"${tool}:util" "${what:-${_name:-${pkgbase:-$pkgname}}}" "$where" "$PKGVER"
				fi
				if type -t "${tool}:deps" 2> /dev/null | grep -wq function; then
					makepkg --nobuild --nodeps
					sed -Ei.bak '/^depends=\(/,/\)/{/#auto-deps$/d}' PKGBUILD
					(
						for dir in "${pkgname}-${pkgver}" "${_name}" "${_name}-${pkgver}" "${pkgname%*-git}"; do
							[[ -n "$dir" ]] || continue
							[[ -d "$srcdir/$dir" ]] || continue
							cd "$srcdir/$dir" || continue
							break
						done
						"${tool}:deps" "${what}" "${where}"
					) | while read -r line; do
						sed -Ei.bak "/^depends=\(/,/\)/{s@^\)\$@\t'$line' #auto-deps\n\)@}" PKGBUILD
					done
					unset depfunc
				fi
			fi
			echo updating checksums
			updpkgsums -m
			if [ -n "$(git status --porcelain .)" ] || [ "${FORCE_REL_BUMP+defined}" ] && [ "$FORCE_REL_BUMP" != "false" ]; then
				if [ -z "$PKGVER" ] || [ "$(vercmp $PKGVER $pkgver)" = "0" ]; then
					sed -Ei "s/^(pkgrel=)[[:digit:]]+$/\1$((pkgrel + 1))/" PKGBUILD
					msg="[${what:-${_name:-${pkgbase:-$pkgname}}}] pkgrel bump."
				fi
				[ -f ../.nopush ] && msg='[nopush] '"${msg:-automatic commmit.}"
				if ((aurpublish)); then
					makepkg --printsrcinfo > .SRCINFO
				fi
				git add .
				if ((aurpublish)); then
					git commit --template=/dev/null --no-edit
				else
					git commit --template=/dev/null -m "${msg:-automatic push.}"
				fi
			fi
			unset from what where tool
			if git status --porcelain --branch | grep -q ahead && {
				[ ! -f ../.nopush ] || [ "${SKIP_PUSH+defined}" ] && [ "$SKIP_PUSH" != "false" ]
			}; then
				echo "Pushing to upstream:"
				git push
				if ((aurpublish)) && [[ ! -f .noaur ]]; then
					echo "Publishing to aur:"
					aurpublish "$PWD"
				fi
			fi
			exclude+=(
				-e '*.log'
				-e 'PKGBUILD.bak'
				-e '.no*'
				-e 'lock.lck'
			)
			source ./PKGBUILD
			for src in "${source[@]}"; do
				src=${src%%::*}
				src=${src##*/}
				src=${src%.git*}
				if [ -e "$src" ]; then
					exclude+=('-e' "${src}")
				fi
			done
			fakeroot rm -rf src pkg
			git clean -fxd "${exclude[@]}" .
		)
		if ((aurpublish)); then
			cd "$repo" || exit
			git stash pop > /dev/null 2>&1
			cd "$OLDPWD" || exit
		fi
	fi
done
