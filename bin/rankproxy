#!/usr/bin/bash
#
#   Copyright (c) 2009 Matthew Bruenig <matthewbruenig@gmail.com>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

# traps interrupt key to spit out pre-interrupt info
trap finaloutput EXIT

declare -r myname='rankproxies'
declare -r myver='1.5.2'

usage()
{
	echo "${myname} v${myver}"
	echo
	echo "Ranks proxies by their connection and opening speed."
	echo
	echo "Usage: ${myname} [options] PROXYFILE | PROXY"
	echo
	echo "Options:"
	echo "  --version           show program's version number and exit"
	echo "  -h, --help          show this help message and exit"
	echo "  -n NUM              number of servers to output, 0 for all"
	echo "  -m, --max-time NUM  specify a ranking operation timeout, can be decimal number"
	echo "  -t, --times         only output proxies and their response times"
	echo "  -p, --proxy         test a specific PROXY"
	echo "  -v, --verbose       be verbose in output"
	exit 0
}

version()
{
	echo "${myname} (pacman) ${myver}"
	echo "Copyright (c) 2009 Matthew Bruenig <matthewbruenig@gmail.com>."
	echo
	echo "This is free software; see the source for copying conditions."
	echo "There is NO WARRANTY, to the extent permitted by law."
	exit 0
}

err()
{
	echo "$1" >&2
	exit 1
}

# returns the fetching time, or timeout, or unreachable
gettime()
{
	IFS=' ' output=(
		$(
			curl -s -m $MAX_TIME \
				-w "%{time_total} %{http_code}" "https://speed.hetzner.de/100MB.bin" \
				-o/dev/null \
				-x "$1"
		)
	)
	(($? == 28)) && echo timeout && return
	((${output[1]} >= 400 || !${output[1]})) && echo unreachable && return
	echo "${output[0]}"
}

# This exists to remove the need for a separate interrupt function
finaloutput()
{
	IFS=$'\n' read -r -d '' -a sortedarray < <(
		printf '%s\n' "${timesarray[@]}" | LC_COLLATE=C sort
	)

	# Final output for proxyfile
	numiterator="0"
	if [[ $TIMESONLY ]]; then
		echo
		echo " Servers sorted by time (seconds):"
		for line in "${sortedarray[@]}"; do
			echo "${line#* } : ${line% *}"
			((numiterator++))
			((NUM && numiterator >= NUM)) && break
		done
	else
		for line in "${sortedarray[@]}"; do
			echo "${line#* }"
			((numiterator++))
			((NUM && numiterator >= NUM)) && break
		done
	fi
	exit 0
}

# Argument parsing
[[ $1 ]] || usage
while [[ $1 ]]; do
	if [[ ${1:0:2} = -- ]]; then
		case "${1:2}" in
			help) usage ;;
			version) version ;;
			max-time)
				[[ $2 ]] || err "Must specify number."
				MAX_TIME="$2"
				shift 2
				;;
			times)
				TIMESONLY=1
				shift
				;;
			verbose)
				VERBOSE=1
				shift
				;;
			proxy)
				CHECKPROXY=1
				[[ $2 ]] || err "Must specify PROXY."
				PROXY="$2"
				shift 2
				;;
			*) err "'$1' is an invalid argument." ;;
		esac
	elif [[ ${1:0:1} = - ]]; then

		if [[ ! ${1:1:1} ]]; then
			[[ -t 0 ]] && err "Stdin is empty."
			IFS=$'\n' linearray=($(< /dev/stdin))
			STDIN=1
			shift
		else
			snum=1
			for ((i = 1; i < ${#1}; i++)); do
				case ${1:$i:1} in
					h) usage ;;
					m)
						[[ $2 ]] || err "Must specify number."
						MAX_TIME="$2"
						snum=2
						;;
					t) TIMESONLY=1 ;;
					v) VERBOSE=1 ;;
					p)
						CHECKPROXY=1
						[[ $2 ]] || err "Must specify PROXY."
						PROXY="$2"
						snum=2
						;;
					n)
						[[ $2 ]] || err "Must specify number."
						NUM="$2"
						snum=2
						;;
					*) err "'$1' is an invalid argument." ;;
				esac
			done
			shift $snum
		fi
	elif [[ -f $1 ]]; then
		FILE="1"
		IFS=$'\n' linearray=($(< $1))
		[[ $linearray ]] || err "File is empty."
		shift
	else
		err "'$1' does not exist."
	fi
done

# Some sanity checks
[[ $NUM ]] || NUM=0
[[ $MAX_TIME ]] || MAX_TIME=10
[[ $FILE && $CHECKPROXY ]] && err "Cannot specify a PROXY and proxyfile."
[[ $FILE || $CHECKPROXY || $STDIN ]] || err "Must specify PROXY, proxyfile, or stdin."

# Single PROXY handling
if [[ $CHECKPROXY ]]; then
	[[ $PROXY = fail ]] && err "PROXY '$PROXY' is malformed."
	[[ $VERBOSE ]] && echo "Testing $PROXY..."
	time=$(gettime "$PROXY")
	echo "$PROXY : $time"
	exit 0
fi

# Get PROXY results from proxyfile, fill up the array, and so on
if [[ $TIMESONLY ]]; then
	echo "Querying servers. This may take some time..."
elif [[ $FILE ]]; then
	echo "# Server list generated by rankproxies on $(date +%Y-%m-%d)"
fi
timesarray=()
for PROXY in "${linearray[@]}"; do
	PROXY=$(tr -d '[:space:]' <<< $PROXY)
	[[ ! $PROXY =~ [0-9.]+:[0-9.]+ ]] && err "PROXY '$PROXY' is malformed."
	time=$(gettime "$PROXY")
	timesarray+=("$time $PROXY")

	# Output
	if [[ $VERBOSE && $TIMESONLY ]]; then
		echo "$PROXY ... $time"
	elif [[ $VERBOSE ]]; then
		echo "# $PROXY ... $time"
	elif [[ $TIMESONLY ]]; then
		echo -n "   *"
	fi
done
